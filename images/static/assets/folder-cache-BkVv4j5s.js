var m=Object.defineProperty;var w=(h,e,a)=>e in h?m(h,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):h[e]=a;var u=(h,e,a)=>w(h,typeof e!="symbol"?e+"":e,a);class g{constructor(){u(this,"dbName","HachiFolderCache");u(this,"dbVersion",1);u(this,"storeName","folders");u(this,"db",null);u(this,"initPromise",null);u(this,"cacheTTL",24*60*60*1e3);this.initPromise=this.initDB()}async initDB(){return new Promise((e,a)=>{const n=indexedDB.open(this.dbName,this.dbVersion);n.onerror=()=>{console.error("Failed to open IndexedDB"),a(n.error)},n.onsuccess=()=>{this.db=n.result,console.log("FolderCache IndexedDB initialized"),e()},n.onupgradeneeded=o=>{const r=o.target.result;if(!r.objectStoreNames.contains(this.storeName)){const t=r.createObjectStore(this.storeName,{keyPath:"id"});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("fullPath","data.fullPath",{unique:!0})}}})}async ensureDB(){if(this.db||await this.initPromise,!this.db)throw new Error("Failed to initialize IndexedDB");return this.db}async cacheFolderData(e){const o=(await this.ensureDB()).transaction([this.storeName],"readwrite").objectStore(this.storeName),r=Date.now(),t=e.map(s=>{const d={id:s.fullPath,data:{...s,lastUpdated:r},timestamp:r,version:1};return new Promise((c,l)=>{const i=o.put(d);i.onsuccess=()=>c(),i.onerror=()=>l(i.error)})});await Promise.all(t),console.log(`Cached ${e.length} folders to IndexedDB`)}async getCachedFolderData(){try{const n=(await this.ensureDB()).transaction([this.storeName],"readonly").objectStore(this.storeName);return new Promise((o,r)=>{const t=n.getAll();t.onsuccess=()=>{const s=t.result,d=Date.now(),c=s.filter(i=>d-i.timestamp<this.cacheTTL);if(c.length===0){console.log("No valid cached folder data found"),o(null);return}const l=c.map(i=>i.data);console.log(`Retrieved ${l.length} folders from cache`),o(l)},t.onerror=()=>{console.error("Failed to retrieve cached folder data"),r(t.error)}})}catch(e){return console.error("Error getting cached folder data:",e),null}}async updateFolderData(e,a){const r=(await this.ensureDB()).transaction([this.storeName],"readwrite").objectStore(this.storeName);return new Promise((t,s)=>{const d=r.get(e);d.onsuccess=()=>{const c=d.result;if(!c){console.warn(`Folder ${e} not found in cache`),t();return}const l={...c,data:{...c.data,...a,lastUpdated:Date.now()},timestamp:Date.now()},i=r.put(l);i.onsuccess=()=>t(),i.onerror=()=>s(i.error)},d.onerror=()=>s(d.error)})}async getCachedFolder(e){try{const o=(await this.ensureDB()).transaction([this.storeName],"readonly").objectStore(this.storeName);return new Promise((r,t)=>{const s=o.get(e);s.onsuccess=()=>{const d=s.result;if(!d){r(null);return}if(Date.now()-d.timestamp>=this.cacheTTL){console.log(`Cache entry for ${e} is expired`),r(null);return}r(d.data)},s.onerror=()=>t(s.error)})}catch(a){return console.error(`Error getting cached folder ${e}:`,a),null}}async isCacheValid(){try{const n=(await this.ensureDB()).transaction([this.storeName],"readonly").objectStore(this.storeName);return new Promise(o=>{const r=n.count();r.onsuccess=()=>{if(r.result===0){o(!1);return}const s=n.index("timestamp"),c=Date.now()-this.cacheTTL,l=s.count(IDBKeyRange.lowerBound(c));l.onsuccess=()=>{const i=l.result;o(i>0)},l.onerror=()=>o(!1)},r.onerror=()=>o(!1)})}catch(e){return console.error("Error checking cache validity:",e),!1}}async clearCache(){const n=(await this.ensureDB()).transaction([this.storeName],"readwrite").objectStore(this.storeName);return new Promise((o,r)=>{const t=n.clear();t.onsuccess=()=>{console.log("Folder cache cleared"),o()},t.onerror=()=>r(t.error)})}async getCacheStats(){try{const n=(await this.ensureDB()).transaction([this.storeName],"readonly").objectStore(this.storeName);return new Promise((o,r)=>{const t=n.count();t.onsuccess=()=>{const s=t.result;if(s===0){o({totalFolders:0,lastUpdated:null});return}const c=n.index("timestamp").openCursor(null,"prev");c.onsuccess=()=>{const l=c.result,i=l?l.key:null;o({totalFolders:s,lastUpdated:i})},c.onerror=()=>r(c.error)},t.onerror=()=>r(t.error)})}catch(e){return console.error("Error getting cache stats:",e),{totalFolders:0,lastUpdated:null}}}setCacheTTL(e){this.cacheTTL=e}isIndexingInProgress(){const e=localStorage.getItem("stored_indexing_endpoint");return console.log("Indexing endpoint:",e),!!e}}const f=new g;export{f};
